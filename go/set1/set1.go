package set1

import (
	"bytes"
	"math"
)

var Eng_freq = map[byte]float64{
	/*
		'a': 0.08167,
		'b': 0.01492,
		'c': 0.02782,
		'd': 0.04253,
		'e': 0.12702,
		'f': 0.02228,
		'g': 0.02015,
		'h': 0.06094,
		'i': 0.06966,
		'j': 0.00153,
		'k': 0.00772,
		'l': 0.04025,
		'm': 0.02406,
		'n': 0.06749,
		'o': 0.07507,
		'p': 0.01929,
		'q': 0.00095,
		'r': 0.05987,
		's': 0.06327,
		't': 0.09056,
		'u': 0.02758,
		'v': 0.00978,
		'w': 0.02360,
		'x': 0.00150,
		'y': 0.01974,
		'z': 0.00074,
	*/

	'\x00': 0.000000,
	'\x01': 0.000000,
	'\x02': 0.000000,
	'\x03': 0.000000,
	'\x04': 0.000000,
	'\x05': 0.000000,
	'\x06': 0.000000,
	'\x07': 0.000000,
	'\x08': 0.000000,
	'\x09': 0.000016,
	'\x0a': 0.019537,
	'\x0b': 0.000000,
	'\x0c': 0.000000,
	'\x0d': 0.000000,
	'\x0e': 0.000000,
	'\x0f': 0.000000,
	'\x10': 0.000000,
	'\x11': 0.000000,
	'\x12': 0.000000,
	'\x13': 0.000000,
	'\x14': 0.000000,
	'\x15': 0.000000,
	'\x16': 0.000000,
	'\x17': 0.000000,
	'\x18': 0.000000,
	'\x19': 0.000000,
	'\x1a': 0.000000,
	'\x1b': 0.000000,
	'\x1c': 0.000000,
	'\x1d': 0.000000,
	'\x1e': 0.000000,
	'\x1f': 0.000000,
	'\x20': 0.168426,
	'\x21': 0.000233,
	'\x22': 0.006524,
	'\x23': 0.000007,
	'\x24': 0.000035,
	'\x25': 0.000000,
	'\x26': 0.000029,
	'\x27': 0.005567,
	'\x28': 0.000376,
	'\x29': 0.000381,
	'\x2a': 0.000235,
	'\x2b': 0.000047,
	'\x2c': 0.011677,
	'\x2d': 0.011866,
	'\x2e': 0.011208,
	'\x2f': 0.003079,
	'\x30': 0.000897,
	'\x31': 0.000735,
	'\x32': 0.001556,
	'\x33': 0.000611,
	'\x34': 0.000418,
	'\x35': 0.000418,
	'\x36': 0.000476,
	'\x37': 0.000426,
	'\x38': 0.000527,
	'\x39': 0.000482,
	'\x3a': 0.000862,
	'\x3b': 0.000104,
	'\x3c': 0.000243,
	'\x3d': 0.000274,
	'\x3e': 0.000329,
	'\x3f': 0.001193,
	'\x40': 0.000013,
	'\x41': 0.001891,
	'\x42': 0.001223,
	'\x43': 0.000874,
	'\x44': 0.000870,
	'\x45': 0.000738,
	'\x46': 0.000576,
	'\x47': 0.000366,
	'\x48': 0.001037,
	'\x49': 0.007159,
	'\x4a': 0.000588,
	'\x4b': 0.000216,
	'\x4c': 0.000822,
	'\x4d': 0.001259,
	'\x4e': 0.000843,
	'\x4f': 0.000767,
	'\x50': 0.000632,
	'\x51': 0.000056,
	'\x52': 0.000620,
	'\x53': 0.001586,
	'\x54': 0.002407,
	'\x55': 0.000339,
	'\x56': 0.000216,
	'\x57': 0.001160,
	'\x58': 0.000060,
	'\x59': 0.000798,
	'\x5a': 0.000155,
	'\x5b': 0.000218,
	'\x5c': 0.000003,
	'\x5d': 0.000218,
	'\x5e': 0.000000,
	'\x5f': 0.000074,
	'\x60': 0.000003,

	'\x61': 0.057712,
	'\x62': 0.011310,
	'\x63': 0.018468,
	'\x64': 0.034058,
	'\x65': 0.088581,
	'\x66': 0.014459,
	'\x67': 0.017354,
	'\x68': 0.039306,
	'\x69': 0.044454,
	'\x6a': 0.001104,
	'\x6b': 0.009367,
	'\x6c': 0.028441,
	'\x6d': 0.018346,
	'\x6e': 0.050099,
	'\x6f': 0.060210,
	'\x70': 0.014344,
	'\x71': 0.000409,
	'\x72': 0.039728,
	'\x73': 0.042858,
	'\x74': 0.068310,
	'\x75': 0.022875,
	'\x76': 0.005912,
	'\x77': 0.017690,
	'\x78': 0.001012,
	'\x79': 0.016053,
	'\x7a': 0.000934,

	'\x7b': 0.000005,
	'\x7c': 0.000001,
	'\x7d': 0.000005,
	'\x7e': 0.000000,
	'\x7f': 0.000000,
	'\x80': 0.000000,
	'\x81': 0.000000,
	'\x82': 0.000000,
	'\x83': 0.000000,
	'\x84': 0.000000,
	'\x85': 0.000000,
	'\x86': 0.000000,
	'\x87': 0.000000,
	'\x88': 0.000000,
	'\x89': 0.000000,
	'\x8a': 0.000000,
	'\x8b': 0.000000,
	'\x8c': 0.000003,
	'\x8d': 0.000000,
	'\x8e': 0.000000,
	'\x8f': 0.000000,
	'\x90': 0.000000,
	'\x91': 0.000000,
	'\x92': 0.000000,
	'\x93': 0.000000,
	'\x94': 0.000000,
	'\x95': 0.000000,
	'\x96': 0.000000,
	'\x97': 0.000000,
	'\x98': 0.000000,
	'\x99': 0.000000,
	'\x9a': 0.000000,
	'\x9b': 0.000000,
	'\x9c': 0.000000,
	'\x9d': 0.000000,
	'\x9e': 0.000000,
	'\x9f': 0.000000,
	'\xa0': 0.000001,
	'\xa1': 0.000001,
	'\xa2': 0.000000,
	'\xa3': 0.000000,
	'\xa4': 0.000000,
	'\xa5': 0.000000,
	'\xa6': 0.000000,
	'\xa7': 0.000000,
	'\xa8': 0.000000,
	'\xa9': 0.000001,
	'\xaa': 0.000000,
	'\xab': 0.000000,
	'\xac': 0.000000,
	'\xad': 0.000000,
	'\xae': 0.000000,
	'\xaf': 0.000000,
	'\xb0': 0.000000,
	'\xb1': 0.000000,
	'\xb2': 0.000000,
	'\xb3': 0.000000,
	'\xb4': 0.000000,
	'\xb5': 0.000000,
	'\xb6': 0.000000,
	'\xb7': 0.000000,
	'\xb8': 0.000000,
	'\xb9': 0.000000,
	'\xba': 0.000000,
	'\xbb': 0.000000,
	'\xbc': 0.000000,
	'\xbd': 0.000000,
	'\xbe': 0.000000,
	'\xbf': 0.000000,
	'\xc0': 0.000000,
	'\xc1': 0.000000,
	'\xc2': 0.000000,
	'\xc3': 0.000001,
	'\xc4': 0.000000,
	'\xc5': 0.000000,
	'\xc6': 0.000000,
	'\xc7': 0.000000,
	'\xc8': 0.000000,
	'\xc9': 0.000000,
	'\xca': 0.000000,
	'\xcb': 0.000000,
	'\xcc': 0.000000,
	'\xcd': 0.000000,
	'\xce': 0.000000,
	'\xcf': 0.000000,
	'\xd0': 0.000000,
	'\xd1': 0.000000,
	'\xd2': 0.000000,
	'\xd3': 0.000000,
	'\xd4': 0.000000,
	'\xd5': 0.000000,
	'\xd6': 0.000000,
	'\xd7': 0.000000,
	'\xd8': 0.000000,
	'\xd9': 0.000000,
	'\xda': 0.000000,
	'\xdb': 0.000000,
	'\xdc': 0.000000,
	'\xdd': 0.000000,
	'\xde': 0.000000,
	'\xdf': 0.000000,
	'\xe0': 0.000000,
	'\xe1': 0.000000,
	'\xe2': 0.000003,
	'\xe3': 0.000000,
	'\xe4': 0.000000,
	'\xe5': 0.000000,
	'\xe6': 0.000000,
	'\xe7': 0.000000,
	'\xe8': 0.000000,
	'\xe9': 0.000000,
	'\xea': 0.000000,
	'\xeb': 0.000000,
	'\xec': 0.000000,
	'\xed': 0.000000,
	'\xee': 0.000000,
	'\xef': 0.000000,
	'\xf0': 0.000000,
	'\xf1': 0.000000,
	'\xf2': 0.000000,
	'\xf3': 0.000000,
	'\xf4': 0.000000,
	'\xf5': 0.000000,
	'\xf6': 0.000000,
	'\xf7': 0.000000,
	'\xf8': 0.000000,
	'\xf9': 0.000000,
	'\xfa': 0.000000,
	'\xfb': 0.000000,
	'\xfc': 0.000000,
	'\xfd': 0.000000,
	'\xfe': 0.000000,
	'\xff': 0.000000,
}

func Xor(a, b []byte) (x []byte) {
	x = make([]byte, len(a))
	for i := range x {
		x[i] = a[i] ^ b[i]
	}
	return x
}

func XorKey(a, b []byte) (x []byte) {
	x = make([]byte, len(a))
	len_b := len(b)
	for i := range x {
		x[i] = a[i] ^ b[i%len_b]
	}
	return x
}

func RepeatingXorKey(dst, src, key []byte) {
	len_key := len(key)
	if len_key > len(src) {
		panic("set1: key is shorter than src")
	}
	for i, b := range src {
		dst[i] = b ^ key[i%len_key]
	}
}

func XorBytes(dst, a, b []byte) {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}
	for i := 0; i < n; i++ {
		dst[i] = a[i] ^ b[i]
	}
}

func ComputeHist(data []byte) (hist []float64) {
	// !!! Only using lower case
	hist = make([]float64, 0x100)
	len_data := len(data)
	for _, v := range data {
		hist[v]++
	}
	for i := range hist {
		hist[i] /= float64(len_data)
	}
	return hist
}

func ComputeScore(eng_freq map[byte]float64, hist []float64) (res float64) {
	for k, v := range eng_freq {
		res += math.Pow((hist[k]-v), 2.0) / (hist[k] + v + 0.0001)
	}
	return res / 2
}

func BestByteXored(input []byte) (k byte) {

	min_score := 10.0
	min_key := make([]byte, 1)
	key := make([]byte, 1)

	for i := 0x00; i < 0x100; i++ {
		key[0] = byte(i)
		xored := XorKey(input, key)
		hist := ComputeHist(xored)
		score := ComputeScore(Eng_freq, hist)
		if score < min_score {
			min_score = score
			copy(min_key, key)
		}
	}
	return min_key[0]
}

func IsECB(input []byte, bs int) (res bool) {
	n_blocks := len(input) / bs
	for i := 0; i < n_blocks-1; i++ {
		blk_a := input[bs*i : bs*(i+1)]
		for j := i + 1; j < n_blocks; j++ {
			blk_b := input[bs*j : bs*(j+1)]
			if bytes.Equal(blk_a, blk_b) {
				return true
			}
		}
	}
	return false
}
